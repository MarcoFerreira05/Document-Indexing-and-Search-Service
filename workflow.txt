### 2. Program Flow Explanation

#### Initialization Sequence

1. **Server Startup**:

1. `main()` in dserver.c parses command-line arguments
2. Calls `server_init(document_folder, cache_size)`
3. `server_init()` sets up signal handlers, initializes configuration
4. Calls `persistence_init()`, `metadata_init()`, and `cache_init()`
5. Calls `create_pipes()` to create the request and response pipes
6. Then calls `server_run()` to start the main server loop



2. **Client Startup**:

1. `main()` in dclient.c parses command-line arguments
2. Based on the arguments, calls the appropriate client function (e.g., `client_add_document()`)





#### Request-Response Cycle

1. **Client Sends Request**:

1. Client function (e.g., `client_add_document()`) prepares a Request structure
2. Sets the request type and fills in relevant data
3. Calls `send_request(&request)` to send the request to the server
4. `send_request()` opens the REQUEST_PIPE, writes the request, and closes the pipe



2. **Server Receives Request**:

1. In `server_run()`, the server calls `receive_request(&request)`
2. `receive_request()` opens the REQUEST_PIPE, reads a request, and closes the pipe
3. If a request is received, calls `server_handle_request(&request, &response)`



3. **Server Processes Request**:

1. `server_handle_request()` examines the request type
2. Calls the appropriate handler function (e.g., `handle_add_document()`)
3. Handler function performs the requested operation and fills in the response
4. Sets the client_pid in the response to match the request



4. **Server Sends Response**:

1. After processing, `server_handle_request()` calls `send_response(&response)`
2. `send_response()` opens the RESPONSE_PIPE, writes the response, and closes the pipe



5. **Client Receives Response**:

1. Client function calls `receive_response(&response, getpid())`
2. `receive_response()` opens the RESPONSE_PIPE and reads responses
3. Continues reading until it finds a response with matching client_pid
4. Returns the response to the client function, which displays the result





#### Flow of Specific Operations

1. **Add Document** (`-a` option):

1. Client calls `client_add_document(title, authors, year, path)`
2. Formats data as "title|authors|year|path" in the request
3. Server receives request and calls `handle_add_document()`
4. `handle_add_document()` parses the data and calls `metadata_add()`
5. `metadata_add()` creates a new metadata entry and returns a document ID
6. Response includes the document ID and success message



2. **Query Document** (`-c` option):

1. Client calls `client_query_document(doc_id)`
2. Server receives request and calls `handle_query_document()`
3. `handle_query_document()` calls `metadata_get(doc_id)`
4. If found, formats metadata into response and calls `cache_add()`
5. Response includes the document metadata



3. **Delete Document** (`-d` option):

1. Client calls `client_delete_document(doc_id)`
2. Server receives request and calls `handle_delete_document()`
3. `handle_delete_document()` calls `metadata_delete(doc_id)`
4. Also calls `cache_remove(doc_id)` to update the cache
5. Response includes success/failure message



4. **Count Lines** (`-l` option):

1. Client calls `client_count_lines(doc_id, keyword)`
2. Server receives request and calls `handle_count_lines()`
3. `handle_count_lines()` calls `search_count_lines(doc_id, keyword)`
4. `search_count_lines()` uses fork() and exec() to run grep
5. Response includes the line count



5. **Search Documents** (`-s` option without num_processes):

1. Client calls `client_search_keyword(keyword)`
2. Server receives request and calls `handle_search_documents()`
3. `handle_search_documents()` calls `search_documents(keyword, &results, &count)`
4. `search_documents()` checks each document using grep
5. Response includes array of matching document IDs



6. **Parallel Search** (`-s` option with num_processes):

1. Client calls `client_search_keyword_parallel(keyword, num_processes)`
2. Server receives request and calls `handle_search_parallel()`
3. `handle_search_parallel()` calls `search_documents_parallel()`
4. `search_documents_parallel()` creates multiple processes to search in parallel
5. Response includes array of matching document IDs



7. **Shutdown Server** (`-f` option):

1. Client calls `client_shutdown_server()`
2. Server receives request and calls `handle_shutdown()`
3. `handle_shutdown()` sets running = 0 to exit the main loop
4. Server completes current request and then exits





#### Shutdown Sequence

1. **Server Shutdown**:

1. After `running` is set to 0, `server_run()` exits its loop
2. Control returns to `main()`, which calls `server_cleanup()`
3. `server_cleanup()` calls `cache_cleanup()`, `metadata_cleanup()`, and `persistence_cleanup()`
4. Removes the request and response pipes
5. Server process exits





#### Cache and Persistence

1. **Cache Operations**:

1. When a document is queried, `cache_add()` adds it to the cache
2. When a document is deleted, `cache_remove()` removes it from the cache
3. The cache uses an LRU (Least Recently Used) policy for replacement



2. **Persistence Operations**:

1. `metadata_save_to_disk()` is called after adding or deleting documents
2. `metadata_load_from_disk()` is called during server initialization
3. These functions use `persistence_save_metadata()` and `persistence_load_metadata()`
